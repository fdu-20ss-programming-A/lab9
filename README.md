# LAB 9

> 本次LAB目标：
>
> 1. 回顾函数作业
> 2. 回顾递归方法
> 3. Project引导

## 获取及提交Lab

**获取**：通过 `https://github.com/fdu-20ss-programming-A/lab9`或者`超星平台`获取。

**提交**：超星平台上已经发布了LAB9作业，同学需要将每题的**代码**、**运行结果**、个人对题目的思考体会（可选）以**图片**或者**文档**（ word 或者 pdf ）的形式在超星LAB9对应的作业区域提交即可。

**提交物**：代码、运行结果，每题可整理为一份 word 或者 pdf 文档，也可以将两者截在一张图片上提交。

**截止时间**：2020年12月8日 23:59:59

## 回顾函数作业

对上课讲述的打印日历的例子进行改写，输入一个年份，打印整年的日历。

参考答案：

```c
void main() 
{
    int year,month;

    printf("Enter full year (e.g., 2001): ");
    scanf("%d",&year);

    // Prompt the user to enter month
    // printf("Enter month in number between 1 and 12: ");
    // scanf(" %d",&month);
    for(int i = 1; i <= 12; i++){
        // Print calendar for the month of the year
        printMonth(year, month);
    }
}
```

这题比较简单，主要是大家熟悉一下函数的声明和定义，学习如何模块化代码增加可读性。

## 回顾递归

### 什么是递归？

> 假设你在一个电影院，你想知道自己坐在哪一排，但是前面人很多，你懒得去数了，于是你问前一排的人「你坐在哪一排？」，这样前面的人 (代号 A) 回答你以后，你就知道自己在哪一排了——只要把 A 的答案加一，就是自己所在的排了。不料 A 比你还懒，他也不想数，于是他也问他前面的人 B「你坐在哪一排？」，这样 A 可以用和你一模一样的步骤知道自己所在的排。然后 B 也如法炮制。直到他们这一串人问到了最前面的一排，第一排的人告诉问问题的人「我在第一排」。最后大家就都知道自己在哪一排了。
> —— 源自知乎Memoria

### 递归的例子

我们首先有如下计算阶乘的函数声明：

```c
int factorial(int n);
```

这函数会计算 n! = n * (n-1) * (n-2) * ... * 1。 如果用循环直接实现就是从1到n累乘的过程。

当然阶乘还有另外一个公式 n!= n * (n-1)! ，这个公式将计算n的阶乘的转化为计算n-1的阶乘。

```c
int factorial(int n) {
    return n * factorial(n-1);
}
```

但是这个函数存在问题，缺乏终止条件。比如当n == 0 的时候，就应该直接返回，否则，这个function将持续调用自身，直到系统内存崩溃。

```c
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n-1);
}
```

我们可以稍微做一下总结，

> 1. 递归要调用自身。可以解决存在相同子结构的问题。
> 2. 递归需要终止条件。

递归的好处是明显的。相对于循环，它可以简化问题，减少思考量。当它应用于数据结构的分治思想时，它能够发挥更大的作用。

### 上机作业1

这次作业的第一题希望大家完成一个**泰波那契数**（Tribonacci）计算程序。和斐波那契数相似，泰波那契数也与前几项有关。泰波那契数的定义如下：

> T0 = 0,T1 = 1, T2 = 1
> 且在 n >= 0 的条件下
> T{n+3} = Tn + T{n+1} + T{n+2}

例如，T3=T0+T1+T2=2，T4=T1+T2+T3=4。

编写**递归**程序计算T1，T5，T10，T20，T30，T40。学有余力的同学可以尝试计算T80。

注意：

追求难度的同学可以尝试计算T80!。想要计算T80光靠蛮力计算是不行的，所以，得想点办法咯~



## Project引导

LAB7大家完成了一个支持WASD的2D小游戏，接下来大家就要开始向推箱子游戏靠近啦。本次LAB的目标是帮助大家完成初始版本的推箱子游戏，有想法的同学可以开始写Project。

在LAB7中，地图已经拥有了箱子，玩家，墙壁，空地这些元素。接下来我们需要加上**箱子**这个元素。箱子是游戏中唯一能够与玩家交互的物体，属于推箱子中比较复杂的部分。对于这个新元素，我们想想它有什么特性？

+ 箱子与墙壁一样无法跨越，属于实体。
+ 单个箱子能够被玩家推动而改变位置
+ 玩家无法一次性推动多个箱子
+ 箱子不能与墙壁重合
+ \* 箱子可以达到目标区域
+ \* 所有箱子到达目标区域后游戏胜利

（带\*的不是这次LAB的必做任务）

接下来考虑箱子的储存形式，有两种思路：

1. 箱子和人物一样属于动态元素，所以也可以采用一个包含两项的数组记录箱子的坐标， 箱子被移动时与人物类似只需要修改箱子的坐标。打印地图时，先将箱子在地图上的位置替换为箱子对应的字符，打印结束后再修改回空地。这种做法需要储存所有箱子坐标的数组。
2. 箱子和墙壁一样直接储存在地图中，程序没有单独储存箱子的位置。当箱子被移动时，将地图上箱子的方格与移动目标方格交换位置。这种做法比较形象，容易理解。但是需要判断胜利条件时，遍历的复杂度比较大。

当然，这两种做法也可以结合使用。

### 上机作业2

LAB9希望大家在之前的基础上完成简单的推箱子功能。核心的功能点包括：(1) 地图上能够显示箱子 (2) 玩家可以朝四个方向推动箱子 (3) 箱子不能穿越墙壁  (4) 玩家无法推动多个箱子。

同学们可以尝试用函数封装功能，让代码结构更加清晰易懂。

本次LAB需要提交**代码**以及**核心功能实现的截图**。（已经完成Project的同学在提交的作业中说明，并提交对应功能的截图即可）

另外，同学们可以在这个基础上开始实现Project了，地图方面可以先用静态的二维数组代替。